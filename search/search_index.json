{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Gracias por participar en la encuesta","text":"<p>Por favor dir\u00edjase a: Arithmetic-Logic Unit.</p>"},{"location":"about/","title":"About","text":"<p>This documentation template has been developed as part of a graduation project in Computer Engineering. Below are the authors responsible for the creation and development of this document:</p> <ul> <li>Alejandro Chavarr\u00eda</li> <li>Alejandro Soto</li> </ul> <p>This documentation template has been designed to provide a clear and comprehensive structure for the technical description of RTL hardware modules. We extend our gratitude to all collaborators and sources that contributed to the creation of this template.</p> <p>For more information about the project, please refer to the associated GitHub organization OpenCEHardware.</p>"},{"location":"alu/","title":"Arithmetic logic unit (ALU)","text":""},{"location":"alu/#description","title":"Description","text":"<p>The <code>hsv_core_alu</code> module is a two-stage Arithmetic Logic Unit (ALU) designed as part of the execute and memory stage within the <code>hsv_core</code> architecture. Its primary function is to perform the arithmetic and logical operations of a RV32I architecture on input data from the pipeline stages and generate results to be used in subsequent stages.</p>"},{"location":"alu/#general-desing","title":"General Desing","text":"<p>The ALU module consists of two stages for computation and a pipelining buffer, as described not available in demo.</p> <ul> <li> <p>First Stage - Bitwise Operations and Setup: This stage (<code>hsv_core_alu_bitwise_setup</code>) handles the initial processing of input operands, preparing them for further arithmetic and bitwise operations. Key functions include:</p> <ul> <li>Logical Operations: Implements AND, OR, XOR, and PASS operations based on control signals (PASS = no logical operation needed).</li> <li>Shift Operations: Prepares data for left and right shifts, including sign-extended shifts and zero extensions.</li> <li>Setup for Arithmetic Operations: Prepares operands for addition, extending them to accommodate sign bits or applying negation as required.</li> </ul> </li> <li> <p>Second Stage - Shift and Add: This stage (<code>hsv_core_alu_shift_add</code>) performs the main arithmetic and shift operations:</p> <ul> <li>Addition: Implements a 33-bit addition, including handling for signed comparisons using a sign-extended representation.</li> <li>Shifting: Handles logical and arithmetic shifts, both left and right, using a unified shift logic.</li> <li>Comparison Operations: Evaluates less-than comparisons using a simple arithmetic subtraction approach, adjusting signs when necessary. This is a particular case of addittion.</li> </ul> </li> <li> <p>Piping: The results from the ALU are buffered using an <code>hs_skid_buffer</code>, which manages pipeline stalls, flush requests and the correct data flow to the next stages. The buffer is parameterized to match the data width of <code>commit_data</code>.</p> </li> </ul>"},{"location":"alu/#design-considerations-and-features","title":"Design Considerations and Features","text":"<ul> <li> <p>Sequential and Flush Control: The ALU is clocked using <code>clk_core</code> and reset with <code>rst_core_n</code>. It includes flush signals (<code>flush_req</code> and <code>flush_ack</code>) to manage pipeline flushing, allowing for the termination of in-progress operations if necessary, such as when a branch is mispredicted or an exception occurs.</p> </li> <li> <p>Data Interface: The module uses a ready-valid handshake protocol for data communication, with input (<code>valid_i</code>, <code>ready_i</code>) and output (<code>valid_o</code>, <code>ready_o</code>) signals facilitating the exchange of data between the ALU and other stages of the pipeline. The ALU receives operand data through the <code>alu_data</code> structure and outputs the results through a <code>commit_data</code> structure.</p> </li> <li> <p>Pipelining: The ALU design is fully pipelined to enhance throughput, allowing different operations to be processed concurrently in separate stages. This means there can be up three instructions at the same time in the ALU (one in bitwise setup, one in shift and add and one buffered at the pipe).</p> </li> <li> <p>Shift and Add Integration: Every instruction produces both a shifted and an added result. Depending on the operation, one of the outputs is chosen. Only one is ever selected for an instruction.</p> </li> <li> <p>Support for Signed and Unsigned Operations: The module supports both signed and unsigned arithmetic and logical operations as needed for a compliant RV32I implementation.</p> </li> <li> <p>Modular Design: The ALU is designed with clear modular boundaries (<code>bitwise_setup</code> and <code>shift_add</code>), allowing for easy maintenance, testing, and potential future expansions or optimizations.</p> </li> <li> <p>Error Handling: When illegal instructions are detected by the decode stage, the issue logic routes the instruction through the ALU. This is because ALU results can be easily discarded and never produce errors on their own.</p> </li> </ul>"},{"location":"alu/#io","title":"I/O","text":""},{"location":"alu/#input-table","title":"Input Table","text":"Input Name Direction Type Description <code>clk_core</code> Input <code>logic</code> Core clock signal for sequential operations. <code>rst_core_n</code> Input <code>logic</code> Active-low reset signal for core operations. <code>flush_req</code> Input <code>logic</code> Request signal to flush the ALU operations. <code>alu_data</code> Input <code>alu_data_t</code> Input data structure containing ALU operands and control signals. <code>valid_i</code> Input <code>logic</code> Valid signal indicating the input data is ready to be processed. <code>ready_i</code> Input <code>logic</code> Ready signal from the next stage indicating it can accept data."},{"location":"alu/#output-table","title":"Output Table","text":"Output Name Direction Type Description <code>flush_ack</code> Output <code>logic</code> Acknowledge signal indicating flush has been processed. <code>ready_o</code> Output <code>logic</code> Ready signal indicating the ALU can accept new input data. <code>commit_data</code> Output <code>commit_data_t</code> Output data structure containing the results of ALU operations. <code>valid_o</code> Output <code>logic</code> Valid signal indicating that the output data is ready to be consumed."},{"location":"alu/#localparams-and-structs","title":"Localparams and Structs","text":""},{"location":"alu/#alu_data_t-struct-table","title":"<code>alu_data_t</code> Struct Table","text":"<p>This is the data that directly tells the ALU what operation to do.</p> Field Name Type Description <code>illegal</code> <code>logic</code> Indicates if the instruction is illegal; set to 1 for illegal instructions and 0 for valid ALU instructions. <code>negate</code> <code>logic</code> Control signal to negate the operand(s). <code>flip_signs</code> <code>logic</code> Control signal to flip the signs of the operand(s). <code>bitwise_select</code> <code>alu_bitwise_t</code> Specifies the bitwise operation to be performed by the ALU. <code>sign_extend</code> <code>logic</code> Control signal to extend the sign of the operands. <code>is_immediate</code> <code>logic</code> Indicates whether the second operand is an immediate value. <code>compare</code> <code>logic</code> Control signal to perform a comparison operation. <code>out_select</code> <code>alu_out_t</code> Selects the output result generated by the ALU . <code>pc_relative</code> <code>logic</code> Control signal indicating that the operation is relative to the program counter (PC). <code>common</code> <code>exec_mem_common_t</code> Contains common execution and memory-related control signals shared across multiple execution units."},{"location":"alu/#exec_mem_common_t-struct-table","title":"<code>exec_mem_common_t</code> Struct Table","text":"<p>This is a shared structure present in all execute and memory stage modules. ALU extracts the operands from here.</p> Field Name Type Description <code>token</code> <code>insn_token</code> Token representing the instruction id. <code>pc</code> <code>word</code> The program counter (PC) value associated with the instruction. <code>pc_increment</code> <code>word</code> Next instruction, PC+4 <code>rs1</code> <code>word</code> The value of the first source register (rs1). <code>rs2</code> <code>word</code> The value of the second source register (rs2). <code>immediate</code> <code>word</code> The immediate value associated with the instruction, if applicable."},{"location":"alu/#alu-operation-table","title":"ALU Operation Table","text":"Mnemonic <code>add</code> <code>addi</code> <code>sub</code> <code>and</code> <code>andi</code> <code>or</code> <code>ori</code> <code>xor</code> <code>xori</code> <code>sll</code> <code>slli</code> <code>srl</code> <code>srli</code> <code>sra</code> <code>srai</code> <code>slt</code> <code>slti</code> <code>sltu</code> <code>sltiu</code> <code>lui</code> <code>auipc</code> Operation <code>q = a + b</code> <code>q = a + b</code> <code>q = a - b</code> <code>q = a &amp; b</code> <code>q = a &amp; b</code> <code>q = a | b</code> <code>q = a | b</code> <code>q = a ^ b</code> <code>q = a ^ b</code> <code>q = a &lt;&lt; b</code> <code>q = a &lt;&lt; b</code> <code>q = a &gt;&gt; b</code> <code>q = a &gt;&gt; b</code> <code>q = a &gt;&gt;&gt; b</code> <code>q = a &gt;&gt;&gt; b</code> <code>q = a &lt; b</code> <code>q = a &lt; b</code> <code>q = a &lt; b</code> <code>q = a &lt; b</code> <code>q = b</code> <code>q = pc + b</code> is_immediate 0 1 0 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 out_select <code>ALU_OUT_ADDER</code> <code>ALU_OUT_ADDER</code> <code>ALU_OUT_ADDER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_ADDER</code> <code>ALU_OUT_ADDER</code> <code>ALU_OUT_ADDER</code> <code>ALU_OUT_ADDER</code> <code>ALU_OUT_ADDER</code> <code>ALU_OUT_ADDER</code> bitwise_select <code>x</code> <code>x</code> <code>x</code> <code>ALU_BITWISE_AND</code> <code>ALU_BITWISE_AND</code> <code>ALU_BITWISE_OR</code> <code>ALU_BITWISE_OR</code> <code>ALU_BITWISE_XOR</code> <code>ALU_BITWISE_XOR</code> <code>ALU_BITWISE_PASS</code> <code>ALU_BITWISE_PASS</code> <code>ALU_BITWISE_PASS</code> <code>ALU_BITWISE_PASS</code> <code>ALU_BITWISE_PASS</code> <code>ALU_BITWISE_PASS</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> sign_extend <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> 0 0 1 1 <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> negate 0 0 1 <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> 1 1 0 0 0 0 1 1 1 1 0 0 flip_signs 0 0 0 <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> 1 1 0 0 0 0 compare 0 0 0 <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> 1 1 1 1 0 0 pc_relative 0 0 0 <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> 0 0 0 0 0 1 common.rs1 a a a a a a a a a a a a a a a a a a a 0 <code>x</code> common.rs2 b <code>x</code> b b <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> <code>x</code> <code>x</code> common.immediate <code>x</code> b <code>x</code> <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> b b b"},{"location":"alu/#submodule-diagram","title":"Submodule Diagram","text":"uarch-alu"}]}